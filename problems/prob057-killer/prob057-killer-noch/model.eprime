language ESSENCE' 1.0

given gridSize: int(1..)
given numHints: int(1..)
given maxHintCells: int(1..)
letting hintSumIndex be maxHintCells + 1
given hintMatrix:
        matrix indexed by [int(1..numHints), int(1..hintSumIndex),
                           int(1..2)] of int(0..)
letting let1 be gridSize * gridSize
letting let2 be gridSize * gridSize
letting let3 be gridSize * gridSize
find solutionGrid:
        matrix indexed by [int(1..let1), int(1..let2)] of int(1..let3)
such that
    and([allDiff(solutionGrid[.., i, ..]) /\ allDiff(solutionGrid[i, ..])
             | i : int(1..gridSize * gridSize)]),
    and([or([and([numberMapping_Function1D[boxColumn + (boxRow - 1) * gridSize] =
                  solutionGrid[gridColumn * gridSize + boxColumn, gridRow * gridSize + boxRow]
                      | boxColumn : int(1..gridSize), boxRow : int(1..gridSize)])
                 | numberMapping_Function1D : matrix indexed by [int(1..gridSize *
                                                                        gridSize)] of int(1..gridSize * gridSize),
                   allDiff(numberMapping_Function1D),
                   and([or([numberMapping_Function1D[q4] = q3 | q4 : int(1..gridSize * gridSize)])
                            | q3 : int(1..gridSize * gridSize)])])
             | gridColumn : int(0..gridSize - 1), gridRow : int(0..gridSize - 1)]),
    and([sum([solutionGrid[hintMatrix[hintSet, index, 1],
                           hintMatrix[hintSet, index, 2]]
                  | index : int(1..hintMatrix[hintSet, hintSumIndex, 2])])
         = hintMatrix[hintSet, hintSumIndex, 1]
             | hintSet : int(1..numHints)])

